using KurrentDB.Client;
using Microsoft.Extensions.Logging;
using Microsoft.OpenApi;
using Shared.Extensions;
using Swashbuckle.AspNetCore.SwaggerGen;

namespace CallbackHandler.Bootstrapper;

using Common;
using EventStore.Client;
using Lamar;
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Diagnostics.HealthChecks;
using Newtonsoft.Json;
using Newtonsoft.Json.Serialization;
using Shared.EventStore.Extensions;
using Shared.General;
using Shared.Middleware;
using Swashbuckle.AspNetCore.Filters;
using System;
using System.Collections.Generic;
using System.Diagnostics.CodeAnalysis;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Text.Json;

[ExcludeFromCodeCoverage]
public class MiddlewareRegistry :ServiceRegistry
{
    public MiddlewareRegistry()
    {
        String connectionString = Startup.Configuration.GetValue<String>("EventStoreSettings:ConnectionString");
        KurrentDBClientSettings eventStoreSettings = KurrentDBClientSettings.Create(connectionString);

        this.AddHealthChecks().AddEventStore(eventStoreSettings, userCredentials: eventStoreSettings.DefaultCredentials,
                                             name: "Eventstore", failureStatus: HealthStatus.Unhealthy, tags: new[] { "db", "eventstore" });

        this.AddSwaggerGen(AddSwaggerAction);
        this.AddSwaggerExamples();

        this.AddControllers().AddNewtonsoftJson(options =>
        {
            options.SerializerSettings.ReferenceLoopHandling = ReferenceLoopHandling.Ignore;
            options.SerializerSettings.TypeNameHandling = TypeNameHandling.None;
            options.SerializerSettings.Formatting = Formatting.Indented;
            options.SerializerSettings.DateTimeZoneHandling = DateTimeZoneHandling.Utc;
            options.SerializerSettings.ContractResolver = new CamelCasePropertyNamesContractResolver();
        });

        Assembly assembly = this.GetType().GetTypeInfo().Assembly;
        this.AddMvcCore().AddApplicationPart(assembly).AddControllersAsServices();

        bool logRequests = ConfigurationReader.GetValueOrDefault<Boolean>("MiddlewareLogging", "LogRequests", true);
        bool logResponses = ConfigurationReader.GetValueOrDefault<Boolean>("MiddlewareLogging", "LogResponses", true);
        LogLevel middlewareLogLevel = ConfigurationReader.GetValueOrDefault<LogLevel>("MiddlewareLogging", "MiddlewareLogLevel", LogLevel.Warning);
        
        this.AddSingleton(new RequestResponseMiddlewareLoggingConfig(middlewareLogLevel, logRequests, logResponses));

        this.ConfigureHttpJsonOptions(options => {
            options.SerializerOptions.PropertyNamingPolicy = new SnakeCaseNamingPolicy();
            options.SerializerOptions.PropertyNameCaseInsensitive = true; // optional, but safer
        });
    }

    private void AddSwaggerAction(SwaggerGenOptions c) {
        c.SwaggerDoc("v1", new OpenApiInfo { Title = "Callback Handler API", Version = "1.0", Description = "A REST Api to handle callback requests from external parties API's.", Contact = new OpenApiContact { Name = "Stuart Ferguson", Email = "golfhandicapping@btinternet.com" } });
        // add a custom operation filter which sets default values
        c.OperationFilter<SwaggerDefaultValues>();
        c.ExampleFilters();

        //Locate the XML files being generated by ASP.NET...
        DirectoryInfo directory = new(AppContext.BaseDirectory);
        FileInfo[] xmlFiles = directory.GetFiles("*.xml");

        //... and tell Swagger to use those XML comments.
        foreach (FileInfo fileInfo in xmlFiles) {
            c.IncludeXmlComments(fileInfo.FullName);
        }
    }
}
